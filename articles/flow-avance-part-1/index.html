<!DOCTYPE html><html ><head><title data-react-helmet="true">Flow avancé - Première partie | Putain de code</title><meta data-react-helmet="true" charset="UTF-8"/><meta data-react-helmet="true" name="description" value="Blog participatif de la communauté dev"/><meta data-react-helmet="true" content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/><meta data-react-helmet="true" content="summary_large_image" name="twitter:card"/><meta data-react-helmet="true" content="Putain de code !" property="og:site_name"/><meta data-react-helmet="true" content="@putaindecode" name="twitter:site"/><meta data-react-helmet="true" content="Putain de code" property="og:title"/><meta data-react-helmet="true" content="Putain de code" name="twitter:title"/><meta data-react-helmet="true" content="https://putaindecode.io/public/images/website/share.jpg" property="og:image"/><meta data-react-helmet="true" content="https://putaindecode.io/public/images/website/share.jpg" name="twitter:image"/><meta data-react-helmet="true" content="1500" property="og:image:width"/><meta data-react-helmet="true" content="777" property="og:image:height"/><link data-react-helmet="true" title="RSS Feed" href="/api/articles/feeds/desc/feed.xml" rel="alternate" type="application/rss+xml"/><link data-react-helmet="true" href="/public/favicon.ico" rel="shortcut icon"/><link data-react-helmet="true" href="https://putaindecode.io/articles/flow-avance-part-1" rel="canonical"/><script data-react-helmet="true" >window.ga =
        window.ga ||
        function() {
          (ga.q = ga.q || []).push(arguments);
        };
      ga.l = +new Date();
      ga("create", "UA-43f771806-1", "auto");
      ga("send", "pageview");</script><script data-react-helmet="true" async="true" src="https://www.google-analytics.com/analytics.js"></script><script>window.PAGES_BOOT_MODE="hydrate";</script></head><div id="root"><style data-emotion-rpcss="cv6q29 cqg32g vfl2jy 94ols9 1nvx7co 1qdfdal">@-webkit-keyframes animation-cv6q29{0%{opacity:0;-webkit-transform:translateY(20px);-ms-transform:translateY(20px);transform:translateY(20px);}}@keyframes animation-cv6q29{0%{opacity:0;-webkit-transform:translateY(20px);-ms-transform:translateY(20px);transform:translateY(20px);}}body{padding:0;margin:0;background-color:#fff;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Roboto","Oxygen","Ubuntu","Cantarell","Fira Sans","Droid Sans","Helvetica Neue",sans-serif;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;min-height:100vh;overflow-x:hidden;}@media (prefers-color-scheme:dark){body{background-color:#222;}}#root{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:stretch;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}html{color:#46515B;font-size:1em;line-height:1.4;-webkit-font-smoothing:antialiased;-webkit-text-size-adjust:100%;}@media (prefers-color-scheme:dark){html{color:#ddd;}}a{color:#CC0613;-webkit-text-decoration:underline;text-decoration:underline;}@media (prefers-color-scheme:dark){a{color:#ddd;}}a:hover{-webkit-text-decoration:none;text-decoration:none;}*,*:before,*:after{box-sizing:border-box;}</style><style data-emotion-rpcss="u6xx5u">.rpcss-u6xx5u{background-color:#000;padding:10px;color:#fff;text-align:center;}</style><div class="rpcss-u6xx5u"><style data-emotion-rpcss="fyih5c">.rpcss-fyih5c{font-size:24px;font-weight:700;}</style><div class="rpcss-fyih5c" role="heading">Black Lives Matter</div><div><style data-emotion-rpcss="th8dfi">.rpcss-th8dfi{font-size:20px;color:#8CBEF9;}</style><a class="rpcss-th8dfi" href="https://blacklivesmatters.carrd.co/#">Comment aider</a> • <a class="rpcss-th8dfi" href="https://minnesotafreedomfund.org">Minnesota Freedom Fund</a> • <a class="rpcss-th8dfi" href="https://www.okpal.com/adama-traore/#/">Justice Pour Adama</a></div></div><style data-emotion-rpcss="18k9t66">.rpcss-18k9t66{background-color:#CC0613;background-image:linear-gradient(180deg,#E51D58 0%,#CC0613 100%);}</style><header class="rpcss-18k9t66" style="background-image:linear-gradient(to bottom, hsl(212, 100%, 35%), hsl(212, 100%, 30%))"><style data-emotion-rpcss="qx7dny">.rpcss-qx7dny{width:100%;max-width:1024px;margin:0 auto;padding:0 10px;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:stretch;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;}</style><div class="rpcss-qx7dny"><style data-emotion-rpcss="7s9om2">.rpcss-7s9om2{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;padding:20px 0 50px;}</style><div class="rpcss-7s9om2"><style data-emotion-rpcss="gdpa5c">.rpcss-gdpa5c{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-text-decoration:none;text-decoration:none;}</style><a class="rpcss-gdpa5c" href="/"><style data-emotion-rpcss="1lm4738">.rpcss-1lm4738{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-text-decoration:none;text-decoration:none;padding-bottom:10px;}</style><div class="rpcss-1lm4738"><style data-emotion-rpcss="13o7eu2">.rpcss-13o7eu2{display:block;}</style><svg class="rpcss-13o7eu2" height="36px" width="36px" viewBox="0 0 36 36"><defs><linearGradient id="PutainDeCodeLogoGradient" x1="50%" x2="50%" y1="0%" y2="127.223881%"><stop offset="0%" stop-color="#E41D57"></stop><stop offset="100%" stop-color="#C60000"></stop></linearGradient></defs><circle cx="18" cy="18" fill="url(#PutainDeCodeLogoGradient)" r="17" stroke="#FFFFFF" stroke-width="2"></circle><polygon fill="#FFFFFF" points="15.9033203 18.2246094 15.9033203 18.3710938 11.2304688 20.5317383 11.2304688 22.8095703 18.0566406 19.184082 18.0566406 17.4116211 11.2304688 13.7788086 11.2304688 16.0639648"></polygon><rect height="14" width="2" fill="#FFFFFF" x="22" y="11"><animate attributeName="opacity" begin="100ms" calcMode="discrete" dur="2s" repeatCount="indefinite" values="1;0"></animate></rect></svg><style data-emotion-rpcss="4cf197">.rpcss-4cf197{width:10px;height:10px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;}</style><div class="rpcss-4cf197"></div><style data-emotion-rpcss="u5k24">.rpcss-u5k24{font-size:22px;color:#fff;font-weight:800;}</style><div aria-level="2" class="rpcss-u5k24" role="heading">Putain de code !</div></div><style data-emotion-rpcss="1nyebg4">.rpcss-1nyebg4{font-size:14px;color:rgba(255,255,255,0.8);text-align:center;}</style><div class="rpcss-1nyebg4">Blog participatif de la communauté dev</div></a></div></div></header><style data-emotion-rpcss="kcj2v3">.rpcss-kcj2v3{background-color:#F9F6F6;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}@media (prefers-color-scheme:dark){.rpcss-kcj2v3{background-color:#111;}}</style><div class="rpcss-kcj2v3"><style data-emotion-rpcss="ees1g6">.rpcss-ees1g6{-webkit-animation:animation-cv6q29 500ms ease-out 0ms 1 normal none running;animation:animation-cv6q29 500ms ease-out 0ms 1 normal none running;}</style><div class="rpcss-ees1g6"><div class="rpcss-qx7dny"><style data-emotion-rpcss="1ktvb3t">.rpcss-1ktvb3t{font-size:42px;font-weight:800;text-align:center;padding-top:40px;line-height:1.2;}</style><div aria-level="1" class="rpcss-1ktvb3t" role="heading">Flow avancé - Première partie</div><style data-emotion-rpcss="4ach9y">.rpcss-4ach9y{font-size:16px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;padding-top:10px;padding-bottom:40px;color:#46515B;-webkit-text-decoration:none;text-decoration:none;}@media (prefers-color-scheme:dark){.rpcss-4ach9y{color:#ccc;}}</style><a class="rpcss-4ach9y" href="https://github.com/zoontek"><style data-emotion-rpcss="uco8i7">.rpcss-uco8i7{width:32px;height:32px;border-radius:100%;margin-right:10px;}</style><img class="rpcss-uco8i7" alt="zoontek" src="https://avatars.githubusercontent.com/zoontek?size=64"/><div>zoontek<!-- --> <!-- -->•<!-- --> <time dateTime="Thu, 23 Nov 2017 00:00:00 GMT">2017/11/23</time></div></a><style data-emotion-rpcss="1ow2283">.rpcss-1ow2283{max-width:640px;width:100%;font-size:18px;margin:0 auto;line-height:1.7;}.rpcss-1ow2283 h2,.rpcss-1ow2283 h3,.rpcss-1ow2283 h4,.rpcss-1ow2283 h5,.rpcss-1ow2283 h6{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Roboto","Oxygen","Ubuntu","Cantarell","Fira Sans","Droid Sans","Helvetica Neue",sans-serif;font-weight:800;line-height:1.2;}.rpcss-1ow2283 img{max-width:100%;background-color:rgba(255,255,255,0.75);}.rpcss-1ow2283 code{font-size:0.9em;font-family:PragmataPro,SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;line-height:1;background-color:#FAF3E1;margin:0 0.2em;}@media (prefers-color-scheme:dark){.rpcss-1ow2283 code{background-color:#4F3804;}}.rpcss-1ow2283 pre{padding:10px;overflow-x:auto;font-size:14px;border-radius:10px;border:2px solid rgba(0,0,0,0.1);-webkit-overflow-scrolling:touch;}@media (prefers-color-scheme:dark){.rpcss-1ow2283 pre{border:2px solid rgba(255,255,255,0.1);}}.rpcss-1ow2283 pre code{font-size:14px;background-color:transparent;margin:0;}.rpcss-1ow2283 blockquote{padding-left:20px;margin:0;font-size:16px;border-left:3px solid rgba(0,0,0,0.4);font-style:italic;}.rpcss-1ow2283 .hljs-keyword{color:#DA6BB5;}.rpcss-1ow2283 .hljs-constructor{color:#DD792B;}.rpcss-1ow2283 .hljs-identifier{color:#1E9EA7;}.rpcss-1ow2283 .hljs-module-identifier{color:#C84682;}.rpcss-1ow2283 .hljs-string{color:#3BA1C8;}.rpcss-1ow2283 .hljs-comment{color:#aaa;}.rpcss-1ow2283 .hljs-operator{color:#DA6BB5;}.rpcss-1ow2283 .hljs-attribute{color:#4CB877;}.rpcss-1ow2283 table{width:100%;text-align:center;}.rpcss-1ow2283 figure{padding:20px 0;}.rpcss-1ow2283 figcaption{text-align:center;}.rpcss-1ow2283 a{overflow-wrap:break-word;}.rpcss-1ow2283 table thead th{background-color:#E4EBEE;padding:10px 0;}</style><div class="rpcss-1ow2283"><p>Ça y est: vos collègues ont enfin réussi à vous motiver à utiliser
<a href="https://flow.org/en/">flow</a>, l'outil de Facebook vous permettant d'ajouter du
typage fort au sein de vos fichiers JavaScript. Seulement voilà, vous avez
utilisé des langages à typage dynamique faible toute votre vie (PHP, JavaScript,
Ruby, Python…), et pour le moment vous vous contentez d'ajouter des annotations
de types <code>Object</code>, <code>Function</code> ou encore <code>string</code>. Frustrés, vous ne pouvez vous
empêcher de crier sur tous les toits que le typage, c'est quand même chiant et
limite une perte de temps puisque flow continue de manquer un tas d'erreurs
potentielles au sein de votre code. Cet article est là pour vous aider à
comprendre de quoi le bouzin est réellement capable, et même si vous n'utilisez
pas flow, il peut servir de chouette introduction un peu poussée à son
utilisation.</p>
<p>Nous utiliserons la dernière version en date à l'heure où j'écris ces lignes,
c'est à dire la 0.59. Pour l'ajouter au sein de votre projet, petit rappel:</p>
<pre><code class="language-sh">npm install --save-dev flow-bin
npm install --save-dev flow-remove-types <span class="hljs-comment"># pour les besoin du tuto - vous pouvez également utiliser babel et le couple babel-plugin-syntax-flow / babel-plugin-transform-flow-strip-types</span>
npx flow init <span class="hljs-comment"># pour créer le fichier .flowconfig</span>
</code></pre>
<p><em>Pour plus d'infos sur npx, c'est <a href="https://www.npmjs.com/package/npx">par ici</a>.
À noter que c'est livré de base avec npm maintenant.</em></p>
<h2>Rappels sur l'inférence de type</h2>
<p>Flow est un outil intelligent: il est inutile de préciser quel type est utilisé
si celui-ci est évident à l'usage.</p>
<pre><code class="language-js"><span class="hljs-comment">// @flow &lt;- le pragma nécessaire pour indiquer à flow d&#x27;analyser votre fichier. À noter que si vous l&#x27;ajoutez sur un projet tout neuf, vous pouvez le configurer pour que celui-ci ne soit pas nécessaire</span>

<span class="hljs-keyword">const</span> quote = <span class="hljs-string">&quot;Thirouin rouin rouin rouin&quot;</span>;
<span class="hljs-built_in">Math</span>.round(quote); <span class="hljs-comment">// erreur! le type attendu est un number</span>

<span class="hljs-keyword">const</span> sayHello = <span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> <span class="hljs-string">`Hello <span class="hljs-subst">${name}</span>`</span>; <span class="hljs-comment">// inféré en (name: any) =&gt; string</span>
sayHello(<span class="hljs-string">&quot;Mathieu&quot;</span>); <span class="hljs-comment">// pas d&#x27;erreur</span>
sayHello(<span class="hljs-number">42</span>); <span class="hljs-comment">// pas d&#x27;erreur</span>
sayHello([<span class="hljs-string">&quot;Mathieu&quot;</span>, <span class="hljs-string">&quot;zoontek&quot;</span>]); <span class="hljs-comment">// erreur: ne peut être un array</span>
</code></pre>
<p>Attention: En annotant la fonction <code>sayHello</code> du type <code>Function</code>, vous perdez
carrément l'inférence. Comme quoi, parfois ne pas préciser le type d'une
variable peut se montrer plus efficace que d'utiliser des types &quot;génériques&quot;
tels que <code>Object</code> ou <code>Function</code> (d'ailleurs je vous encourage à ne jamais le
faire).</p>
<pre><code class="language-js"><span class="hljs-comment">// @flow</span>

<span class="hljs-keyword">const</span> sayHello: <span class="hljs-built_in">Function</span> = <span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> <span class="hljs-string">`Hello <span class="hljs-subst">${name}</span>`</span>; <span class="hljs-comment">// inféré en (name: any) =&gt; any</span>
</code></pre>
<p>Si vous désirez interpoler un string, la bonne façon de faire est bien sûr la
suivante :</p>
<pre><code class="language-js"><span class="hljs-comment">// @flow</span>
<span class="hljs-keyword">const</span> sayHello = <span class="hljs-function">(<span class="hljs-params">name: string</span>) =&gt;</span> <span class="hljs-string">`Hello <span class="hljs-subst">${name}</span>`</span>; <span class="hljs-comment">// (name: string) =&gt; string</span>
sayHello(<span class="hljs-string">&quot;Mathieu&quot;</span>); <span class="hljs-comment">// pas d&#x27;erreur</span>
sayHello(<span class="hljs-number">42</span>); <span class="hljs-comment">// pas d&#x27;erreur</span>
</code></pre>
<h2>Les types primitifs et litéraux</h2>
<p>Le nombre de types primitifs existants en JavaScript est assez restreint. Vous
avez le nombre (<code>number</code>), la chaine de caractères (<code>string</code>), les booléens
(<code>boolean</code>), et bien évidemment les valeurs nulles (<code>null</code>) et inexistantes
(<code>void</code>). À noter que ES2015 a également apporté (<code>Symbol</code>), mais que ce dernier
n'est pas encore supporté par flow.</p>
<pre><code class="language-js"><span class="hljs-comment">// @flow</span>

<span class="hljs-keyword">const</span> a: number = <span class="hljs-number">42</span>;
<span class="hljs-keyword">const</span> b: string = <span class="hljs-string">&quot;Je ne suis pas Coluche, certes&quot;</span>;
<span class="hljs-keyword">const</span> c: boolean = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">const</span> d: <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;
<span class="hljs-keyword">const</span> e: <span class="hljs-keyword">void</span> = <span class="hljs-literal">undefined</span>;
</code></pre>
<p>Afin de vous montrer plus précis encore, vous pouvez également utiliser des
valeurs litérales comme type. Après tout <code>string</code>, ça peut être tout et
n'importe quoi. Si cela peut vous sembler stupide dans un premier temps, ceux-ci
sont <strong>extrêmement</strong> utiles lorsque le système de typage est suffisamment
perfectionné, commme vous le verrez par la suite.</p>
<pre><code class="language-js"><span class="hljs-comment">// @flow</span>

<span class="hljs-keyword">const</span> foo: <span class="hljs-string">&quot;x&quot;</span> = <span class="hljs-string">&quot;x&quot;</span>; <span class="hljs-comment">// pas d&#x27;erreur</span>
<span class="hljs-keyword">const</span> bar: <span class="hljs-number">2</span> = <span class="hljs-number">3</span>; <span class="hljs-comment">// erreur! n&#x27;est pas égal à 2</span>
</code></pre>
<h2>La différence entre <code>any</code>, <code>mixed</code> et <code>*</code></h2>
<p>Comme expliqué au dessus, utiliser <code>any</code> revient à dire à flow qu'une variable
peut être de n'importe quel type et cela est bien sûr extrêmement dangereux.
Heureusement, il existe 2 alternatives plus sûres à connaître :</p>
<ul>
<li><code>mixed</code> qui dit que peu importe le type de la variable passée à une fonction,
l'appel de celle-ci doit pouvoir se faire correctement: vous ne pourrez donc
pas y appeler des méthodes spécifiques à un type de variable en particulier.</li>
<li><code>*</code> qui laisse travailler l'inférence de type de flow.</li>
</ul>
<pre><code class="language-js"><span class="hljs-comment">// @flow</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">arg: mixed</span>) </span>{
  <span class="hljs-built_in">console</span>.log(arg);
} <span class="hljs-comment">// pas d&#x27;erreur: peu importe le type réel du paramètre arg, l&#x27;appel se fera correctement</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params">arg: mixed</span>) </span>{
  <span class="hljs-built_in">console</span>.log(arg.toUpperCase());
} <span class="hljs-comment">// erreur! arg pourrait ne pas être une string</span>

<span class="hljs-keyword">const</span> baz: <span class="hljs-built_in">Array</span>&lt;*&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// inféré en Array&lt;number&gt;</span>
baz.push(<span class="hljs-string">&quot;Hello&quot;</span>); <span class="hljs-comment">// &quot;foo&quot; est maintenant inféré en Array&lt;number | string&gt; (tableau de string ou de numbers)</span>
</code></pre>
<h2>Les types optionnels (ou maybe types)</h2>
<p>Si vous avez déjà utilisé un langage qui essaye d'éviter
<a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare">l'erreur à un milliard de dollars</a>,
vous connaissez sûrement les types <code>Option</code> / <code>Maybe</code>. Ils représentent la
possible absence d'une valeur et sont ici symbolisés à l'aide d'un point
d'interrogation.</p>
<pre><code class="language-js"><span class="hljs-comment">// @flow</span>

<span class="hljs-keyword">let</span> foo: ?string; <span class="hljs-comment">// peut-être une string, null ou undefined</span>
foo = <span class="hljs-string">&quot;foo&quot;</span>; <span class="hljs-comment">// pas d&#x27;erreur</span>
foo = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// pas d&#x27;erreur</span>
foo = <span class="hljs-literal">null</span>; <span class="hljs-comment">// pas d&#x27;erreur</span>
foo = <span class="hljs-number">3</span>; <span class="hljs-comment">// erreur - number n&#x27;est ni une string, ni null, ni undefined</span>

type Bar = {
  baz?: string, <span class="hljs-comment">// baz sera forcément une string si elle est présente</span>
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrongToUpperCase</span>(<span class="hljs-params">str: ?string</span>) </span>{
  <span class="hljs-keyword">return</span> str.toUpperCase(); <span class="hljs-comment">// erreur, str est possiblement nul, vous devez traiter ce cas</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">correctToUpperCase</span>(<span class="hljs-params">str: ?string</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> str === <span class="hljs-string">&quot;string&quot;</span>) {
    <span class="hljs-keyword">return</span> str.toUpperCase(); <span class="hljs-comment">// pas d&#x27;erreur</span>
  }
}
</code></pre>
<h2>Les types génériques (generics)</h2>
<p>Vous souvenez-vous de la syntaxe des tableaux (<code>Array&lt;any&gt;</code>) croisée plus tôt?
Il s'agit de ce qu'on appelle un type générique : un type construit depuis un
autre type. Ainsi, si <code>Array&lt;any&gt;</code> symbolise un tableau de tout et n'importe
quoi, <code>Array&lt;number&gt;</code> symbolisera un tableau de numbers, etc.</p>
<pre><code class="language-js"><span class="hljs-comment">// @flow</span>

<span class="hljs-comment">// on crée un type Classement qui prend en &quot;paramètre&quot; un type générique qu&#x27;on nomme &quot;T&quot;</span>
type Classement&lt;T&gt; = {
  <span class="hljs-attr">first</span>: T,
  <span class="hljs-attr">second</span>: T,
  <span class="hljs-attr">third</span>: T,
};

<span class="hljs-keyword">const</span> numberClassement: Classement&lt;number&gt; = {
  <span class="hljs-attr">first</span>: <span class="hljs-number">42</span>,
  <span class="hljs-attr">second</span>: <span class="hljs-number">7</span>,
  <span class="hljs-attr">third</span>: <span class="hljs-number">1</span>,
};
</code></pre>
<p>Voici quelques exemples de types génériques disponibles out-of-the-box :</p>
<pre><code class="language-js"><span class="hljs-comment">// @flow</span>

<span class="hljs-keyword">const</span> foo: <span class="hljs-built_in">Array</span>&lt;number&gt; = [];

<span class="hljs-keyword">const</span> bar: <span class="hljs-built_in">Map</span>&lt;number, string&gt; = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
bar.set(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;one&quot;</span>);

<span class="hljs-keyword">const</span> baz: <span class="hljs-built_in">Set</span>&lt;number&gt; = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
baz.add(<span class="hljs-number">1</span>);

<span class="hljs-keyword">const</span> p: <span class="hljs-built_in">Promise</span>&lt;number&gt; = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">42</span>);
</code></pre>
<h2>La manipulation d'objets</h2>
<p>Avez vous remarqué que pour le moment, j'ai tenté de ne pas utiliser d'objets au
sein de mes exemples (oui, c'était chiant)? C'est tout simplement car les
possibilités de manipulation des types de ceux-ci sont très nombreuses. Je vous
propose un exemple fleuve histoire d'y voir plus clair.</p>
<p>Un type objet se définit de la sorte :</p>
<pre><code class="language-js"><span class="hljs-comment">// @flow</span>

type User = {
  <span class="hljs-attr">name</span>: string,
  <span class="hljs-attr">pseudo</span>: string,
};

<span class="hljs-keyword">const</span> user: User = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Mathieu&quot;</span>,
  <span class="hljs-attr">pseudo</span>: <span class="hljs-string">&quot;zoontek&quot;</span>,
};

<span class="hljs-comment">// Ce qui n&#x27;exclut pas de faire</span>
<span class="hljs-keyword">const</span> newUser: User = {
  ...user,
  <span class="hljs-attr">age</span>: <span class="hljs-number">26</span>,
}; <span class="hljs-comment">// pas d&#x27;erreur</span>
</code></pre>
<p>Pour sceller les propriétés de notre objet, on utilise la notation <code>{||}</code> :</p>
<pre><code class="language-js"><span class="hljs-comment">// @flow</span>

type User = {|
  name: string,
  <span class="hljs-attr">pseudo</span>: string,
|};

<span class="hljs-keyword">const</span> user: User = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Mathieu&quot;</span>,
  <span class="hljs-attr">pseudo</span>: <span class="hljs-string">&quot;zoontek&quot;</span>,
};

<span class="hljs-keyword">const</span> newUser: User = {
  ...user,
  <span class="hljs-attr">age</span>: <span class="hljs-number">26</span>,
}; <span class="hljs-comment">// erreur! la propriété age n&#x27;existe pas</span>
</code></pre>
<p>Pour indiquer qu'une propriété de notre objet est immutable, on utilise la
notation <code>+</code>. Un must-have pour vos reducers Redux.</p>
<pre><code class="language-js"><span class="hljs-comment">// @flow</span>

type User = {
  +name: string,
  <span class="hljs-attr">pseudo</span>: string,
};

<span class="hljs-keyword">const</span> user: User = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Mathieu&quot;</span>,
  <span class="hljs-attr">pseudo</span>: <span class="hljs-string">&quot;zoontek&quot;</span>,
};

user.name = <span class="hljs-string">&quot;Jean-Michel&quot;</span>; <span class="hljs-comment">// erreur! la valeur de name ne peut-être modifiée</span>

<span class="hljs-keyword">const</span> newUser: User = {
  ...user,
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Jean-Michel&quot;</span>,
}; <span class="hljs-comment">// pas d&#x27;erreur</span>
</code></pre>
<blockquote>
<p>Le spreading c'est vraiment cool! Ça existe aussi pour les types?</p>
</blockquote>
<p>Yep.</p>
<pre><code class="language-js"><span class="hljs-comment">// @flow</span>

type Foo = {| a: number, <span class="hljs-attr">b</span>: string |};
type Bar = {| a: string |};
type Baz = {| ...Foo, ...Bar |}; <span class="hljs-comment">// {| a: string, b: string |}</span>
</code></pre>
<p>Un dernier petit trick sur les objets pour la route? Vous pouvez les utiliser
comme maps :</p>
<pre><code class="language-js"><span class="hljs-comment">// @flow</span>

<span class="hljs-keyword">const</span> foo: { [key: string]: number } = {
  <span class="hljs-attr">bar</span>: <span class="hljs-number">42</span>,
  <span class="hljs-attr">baz</span>: <span class="hljs-string">&quot;whatever&quot;</span>, <span class="hljs-comment">// erreur! les valeurs des propriétés de cet objet doivent être de type number</span>
};
</code></pre>
<h2>Les unions et intersections de types</h2>
<p>Si vous avez remarqué la notation avec <code>|</code> plus tôt, vous vous posez sûrement la
question de ce que ça représente. Il s'agit d'une union de types : la variable
aura une valeur à plusieurs types possibles. Petit conseil : utilisez toujours
une union de types litéraux à la place du simple <code>string</code> lorsque vous
connaissez à l'avance les possibles valeurs de celui-ci.</p>
<pre><code class="language-js"><span class="hljs-comment">// @flow</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHelloOrRound</span>(<span class="hljs-params">arg: string | number</span>) </span>{
  <span class="hljs-comment">// arg peut être une string ou un number</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> arg === <span class="hljs-string">&quot;string&quot;</span> ? <span class="hljs-string">`Hello <span class="hljs-subst">${arg}</span>`</span> : <span class="hljs-built_in">Math</span>.round(arg);
} <span class="hljs-comment">// pas d&#x27;erreur</span>

type Color = <span class="hljs-string">&quot;red&quot;</span> | <span class="hljs-string">&quot;green&quot;</span> | <span class="hljs-string">&quot;blue&quot;</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toHexadecimal</span>(<span class="hljs-params">color: Color</span>) </span>{
  <span class="hljs-keyword">switch</span> (color) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;red&quot;</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;#FF0000&quot;</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;green&quot;</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;#00FF00&quot;</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;blue&quot;</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;#0000FF&quot;</span>;
  }
}

toHexadecimal(<span class="hljs-string">&quot;red&quot;</span>); <span class="hljs-comment">// pas d&#x27;erreur</span>
toHexadecimal(<span class="hljs-string">&quot;green&quot;</span>); <span class="hljs-comment">// pas d&#x27;erreur</span>
toHexadecimal(<span class="hljs-string">&quot;blue&quot;</span>); <span class="hljs-comment">// pas d&#x27;erreur</span>
toHexadecimal(<span class="hljs-string">&quot;pink&quot;</span>); <span class="hljs-comment">// erreur! &quot;pink&quot; n&#x27;est pas une valeur possible</span>
toHexadecimal(<span class="hljs-string">&quot;dog&quot;</span>); <span class="hljs-comment">// erreur! &quot;dog&quot; n&#x27;est pas une valeur possible</span>
</code></pre>
<p>Parfois, une union de types se montre également bien plus efficace pour
modéliser ce que vous souhaitez, à contrario d'un tas de maybe types.</p>
<pre><code class="language-js"><span class="hljs-comment">// @flow</span>

type ApiResponseBadlyTyped = {|
  success: boolean,
  value?: string, <span class="hljs-comment">// value peut être présent</span>
  error?: <span class="hljs-built_in">Error</span>, <span class="hljs-comment">// error peut être présent</span>
|};

<span class="hljs-keyword">const</span> foo: ApiResponseBadlyTyped = { <span class="hljs-attr">success</span>: <span class="hljs-literal">true</span> }; <span class="hljs-comment">// pas d&#x27;erreur alors que j&#x27;attends une value</span>
<span class="hljs-keyword">const</span> bar: ApiResponseBadlyTyped = { <span class="hljs-attr">success</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">error</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;oups!&quot;</span>) }; <span class="hljs-comment">// pas d&#x27;erreur non plus</span>

type ApiResponseCorrectlyTyped =
  | {| success: <span class="hljs-literal">true</span>, <span class="hljs-attr">value</span>: string |}
  | {| success: <span class="hljs-literal">false</span>, <span class="hljs-attr">error</span>: <span class="hljs-built_in">Error</span> |};

<span class="hljs-keyword">const</span> foo: ApiResponseCorrectlyTyped = { <span class="hljs-attr">success</span>: <span class="hljs-literal">true</span> }; <span class="hljs-comment">// erreur! il manque value</span>
<span class="hljs-keyword">const</span> bar: ApiResponseCorrectlyTyped = {
  <span class="hljs-attr">success</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">error</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;oups!&quot;</span>),
}; <span class="hljs-comment">// erreur! si success est à true, on ne doit pas trouver d&#x27;error dans notre objet</span>
<span class="hljs-keyword">const</span> baz: ApiResponseCorrectlyTyped = {
  <span class="hljs-attr">success</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">error</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;oups!&quot;</span>),
}; <span class="hljs-comment">// pas d&#x27;erreur</span>
</code></pre>
<p>Si les unions de types sont le <strong>OU</strong> logique du système de typage, les
intersections de types en sont le <strong>ET</strong>. On les symbolise à l'aide d'un <code>&amp;</code>.</p>
<pre><code class="language-js"><span class="hljs-comment">// @flow</span>

type Foo = { <span class="hljs-attr">a</span>: number };
type Bar = { <span class="hljs-attr">b</span>: string };
type Baz = { <span class="hljs-attr">c</span>: boolean };

<span class="hljs-keyword">const</span> test: Foo &amp; Bar &amp; Baz = {
  <span class="hljs-attr">a</span>: <span class="hljs-number">42</span>,
  <span class="hljs-attr">b</span>: <span class="hljs-string">&quot;whatever&quot;</span>,
  <span class="hljs-attr">c</span>: <span class="hljs-literal">true</span>,
}; <span class="hljs-comment">// pas d&#x27;erreur</span>

<span class="hljs-keyword">let</span> impossible: number &amp; string; <span class="hljs-comment">// sera forcément impossible à initialiser : une valeur ne pourra jamais être un number ET une string</span>
</code></pre>
<p>C'est tout pour le moment! Vous vous doutez que l'on égratigne à peine la
surface de ce qui nous est offert par flow et les systèmes de typage fort en
général. Si vous êtes vraiment impatients de découvrir la suite, je vous renvoie
vers la <a href="https://flow.org/en/docs/">documentation de flow</a>, très bien foutue.
Pour les autres, on devrait sortir très prochainement un article sur le même
sujet (on y parlera classes, interfaces et peut être même types opaques si vous
êtes sages).</p>
<p>Stay tuned! La bise.</p>
</div><style data-emotion-rpcss="v01ydp">.rpcss-v01ydp{max-width:640px;width:100%;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;margin:20px auto;padding:20px;background-color:#fff;border-radius:10px;box-shadow:0 15px 15px -5px rgba(0,0,0,0.2);}@media (prefers-color-scheme:dark){.rpcss-v01ydp{background-color:#222;}}@media (max-width:540px){.rpcss-v01ydp{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}}</style><div class="rpcss-v01ydp"><style data-emotion-rpcss="ty7r4z">.rpcss-ty7r4z{font-weight:800;}</style><div class="rpcss-ty7r4z">Vous avez aimé cet article?</div><style data-emotion-rpcss="bb4ce3">.rpcss-bb4ce3{width:0px;height:10px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;}</style><div class="rpcss-bb4ce3"></div><style data-emotion-rpcss="1pkr03v">.rpcss-1pkr03v{background-color:#00aced;color:#fff;padding:10px 20px;-webkit-text-decoration:none;text-decoration:none;border-radius:5px;font-weight:800;}.rpcss-1pkr03v:active{opacity:0.5;}</style><a class="rpcss-1pkr03v" href="https://www.twitter.com/intent/tweet?text=Flow%20avanc%C3%A9%20-%20Premi%C3%A8re%20partie%20sur%20%40PutainDeCode%20https%3A%2F%2Fputaindecode.io%2Farticles%2Fflow-avance-part-1" target="_blank">Le partager sur Twitter</a></div><style data-emotion-rpcss="x4iqxe">.rpcss-x4iqxe{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;text-align:center;padding:20px;}</style><div class="rpcss-x4iqxe"><style data-emotion-rpcss="gein6x">.rpcss-gein6x{font-size:20px;-webkit-text-decoration:none;text-decoration:none;color:#1E49B5;}</style><a class="rpcss-gein6x" href="/articles">← Articles</a></div><style data-emotion-rpcss="8bodgl">.rpcss-8bodgl{max-width:640px;width:100%;margin:0 auto;padding:20px 0;}</style><div class="rpcss-8bodgl" id="disqus_thread"></div></div></div></div><div class="rpcss-qx7dny"><style data-emotion-rpcss="5518eg">.rpcss-5518eg{margin-top:20px;margin-bottom:20px;background-color:#E4EBEE;border-radius:10px;padding:20px;}@media (prefers-color-scheme:dark){.rpcss-5518eg{background-color:#111;}}</style><div class="rpcss-5518eg"><style data-emotion-rpcss="1gz1i1h">.rpcss-1gz1i1h{font-size:32px;font-weight:800;margin-bottom:20px;text-align:center;}</style><div aria-level="2" class="rpcss-1gz1i1h" role="heading">Ne rien rater</div><style data-emotion-rpcss="1wbispj">.rpcss-1wbispj{font-size:18px;margin-bottom:10px;text-align:center;}</style><div aria-level="3" class="rpcss-1wbispj" role="heading">Sur les réseaux</div><style data-emotion-rpcss="1hyoz7m">.rpcss-1hyoz7m{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;}</style><div class="rpcss-1hyoz7m"><a href="https://twitter.com/PutainDeCode"><img alt="Twitter" height="48" src="/public/images/website/twitter.svg" width="48"/></a><div class="rpcss-4cf197"></div><a href="https://facebook.com/putaindecode"><img alt="Facebook" height="48" src="/public/images/website/facebook.svg" width="48"/></a><div class="rpcss-4cf197"></div><a href="https://github.com/putaindecode"><img alt="Facebook" height="48" src="/public/images/website/github.svg" width="48"/></a><div class="rpcss-4cf197"></div><a href="https://itunes.apple.com/fr/podcast/putain-de-code-!/id1185311825"><img alt="Apple Podcast" height="48" src="/public/images/website/apple-podcast.svg" width="48"/></a><div class="rpcss-4cf197"></div><a href="https://soundcloud.com/putaindecode"><img alt="Soundcloud" height="48" src="/public/images/website/soundcloud.svg" width="48"/></a></div><div aria-level="3" class="rpcss-1wbispj" role="heading">Sur le chat</div><div class="rpcss-1hyoz7m"><a href="https://discord.gg/jtbGNNc"><img alt="Discord" height="48" src="/public/images/website/discord.svg" width="48"/></a></div></div></div><style data-emotion-rpcss="zs8kw7">.rpcss-zs8kw7{background-color:#222;padding:20px 0;}</style><footer class="rpcss-zs8kw7"><div class="rpcss-qx7dny"><style data-emotion-rpcss="79elbk">.rpcss-79elbk{position:relative;}</style><div class="rpcss-79elbk"><style data-emotion-rpcss="1hle0ni">.rpcss-1hle0ni{position:absolute;left:0;top:50%;color:#fff;-webkit-transform:translateY(-50%);-ms-transform:translateY(-50%);transform:translateY(-50%);-webkit-text-decoration:none;text-decoration:none;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><a class="rpcss-1hle0ni" href="/api/articles/feeds/desc/feed.xml"><style data-emotion-rpcss="lvyu5j">.rpcss-lvyu5j{margin-right:10px;}</style><img class="rpcss-lvyu5j" alt="Flux RSS" height="16" src="/public/images/website/rss-feed.svg" width="16"/><style data-emotion-rpcss="um3i31">@media (max-width:400px){.rpcss-um3i31{display:none;}}</style><div class="rpcss-um3i31">Flux RSS</div></a><style data-emotion-rpcss="12cp4l7">.rpcss-12cp4l7{color:rgba(255,255,255,0.5);text-align:center;font-size:14px;}</style><div class="rpcss-12cp4l7">© 2020 Putain de code !</div><style data-emotion-rpcss="1y2rkzl">.rpcss-1y2rkzl{position:absolute;right:0;top:50%;-webkit-transform:translateY(-50%);-ms-transform:translateY(-50%);transform:translateY(-50%);color:#fff;-webkit-text-decoration:none;text-decoration:none;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><a class="rpcss-1y2rkzl" href="https://github.com/putaindecode/putaindecode.io">GitHub</a></div></div></footer></div><script id="initialData" type="text/data">{"lists":{"RE_PRIVATE_NONE":true},"items":{"k":"articles","v":{"k":"flow-avance-part-1","v":{"_0":{"TAG":0,"_0":{"slug":"flow-avance-part-1","filename":"2017-11-23-flow-avance-part-1","title":"Flow avancé - Première partie","date":"Thu, 23 Nov 2017 00:00:00 GMT","draft":false,"meta":{"date":"2017-11-23T00:00:00.000Z","title":"Flow avancé - Première partie","author":"zoontek","oldSlug":"js/flow/advanced-part-1","slug":"flow-avance-part-1"},"body":"<p>Ça y est: vos collègues ont enfin réussi à vous motiver à utiliser\n<a href=\"https://flow.org/en/\">flow</a>, l'outil de Facebook vous permettant d'ajouter du\ntypage fort au sein de vos fichiers JavaScript. Seulement voilà, vous avez\nutilisé des langages à typage dynamique faible toute votre vie (PHP, JavaScript,\nRuby, Python…), et pour le moment vous vous contentez d'ajouter des annotations\nde types <code>Object</code>, <code>Function</code> ou encore <code>string</code>. Frustrés, vous ne pouvez vous\nempêcher de crier sur tous les toits que le typage, c'est quand même chiant et\nlimite une perte de temps puisque flow continue de manquer un tas d'erreurs\npotentielles au sein de votre code. Cet article est là pour vous aider à\ncomprendre de quoi le bouzin est réellement capable, et même si vous n'utilisez\npas flow, il peut servir de chouette introduction un peu poussée à son\nutilisation.</p>\n<p>Nous utiliserons la dernière version en date à l'heure où j'écris ces lignes,\nc'est à dire la 0.59. Pour l'ajouter au sein de votre projet, petit rappel:</p>\n<pre><code class=\"language-sh\">npm install --save-dev flow-bin\nnpm install --save-dev flow-remove-types <span class=\"hljs-comment\"># pour les besoin du tuto - vous pouvez également utiliser babel et le couple babel-plugin-syntax-flow / babel-plugin-transform-flow-strip-types</span>\nnpx flow init <span class=\"hljs-comment\"># pour créer le fichier .flowconfig</span>\n</code></pre>\n<p><em>Pour plus d'infos sur npx, c'est <a href=\"https://www.npmjs.com/package/npx\">par ici</a>.\nÀ noter que c'est livré de base avec npm maintenant.</em></p>\n<h2>Rappels sur l'inférence de type</h2>\n<p>Flow est un outil intelligent: il est inutile de préciser quel type est utilisé\nsi celui-ci est évident à l'usage.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// @flow &lt;- le pragma nécessaire pour indiquer à flow d&#x27;analyser votre fichier. À noter que si vous l&#x27;ajoutez sur un projet tout neuf, vous pouvez le configurer pour que celui-ci ne soit pas nécessaire</span>\n\n<span class=\"hljs-keyword\">const</span> quote = <span class=\"hljs-string\">&quot;Thirouin rouin rouin rouin&quot;</span>;\n<span class=\"hljs-built_in\">Math</span>.round(quote); <span class=\"hljs-comment\">// erreur! le type attendu est un number</span>\n\n<span class=\"hljs-keyword\">const</span> sayHello = <span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> <span class=\"hljs-string\">`Hello <span class=\"hljs-subst\">${name}</span>`</span>; <span class=\"hljs-comment\">// inféré en (name: any) =&gt; string</span>\nsayHello(<span class=\"hljs-string\">&quot;Mathieu&quot;</span>); <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\nsayHello(<span class=\"hljs-number\">42</span>); <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\nsayHello([<span class=\"hljs-string\">&quot;Mathieu&quot;</span>, <span class=\"hljs-string\">&quot;zoontek&quot;</span>]); <span class=\"hljs-comment\">// erreur: ne peut être un array</span>\n</code></pre>\n<p>Attention: En annotant la fonction <code>sayHello</code> du type <code>Function</code>, vous perdez\ncarrément l'inférence. Comme quoi, parfois ne pas préciser le type d'une\nvariable peut se montrer plus efficace que d'utiliser des types &quot;génériques&quot;\ntels que <code>Object</code> ou <code>Function</code> (d'ailleurs je vous encourage à ne jamais le\nfaire).</p>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-keyword\">const</span> sayHello: <span class=\"hljs-built_in\">Function</span> = <span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> <span class=\"hljs-string\">`Hello <span class=\"hljs-subst\">${name}</span>`</span>; <span class=\"hljs-comment\">// inféré en (name: any) =&gt; any</span>\n</code></pre>\n<p>Si vous désirez interpoler un string, la bonne façon de faire est bien sûr la\nsuivante :</p>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// @flow</span>\n<span class=\"hljs-keyword\">const</span> sayHello = <span class=\"hljs-function\">(<span class=\"hljs-params\">name: string</span>) =&gt;</span> <span class=\"hljs-string\">`Hello <span class=\"hljs-subst\">${name}</span>`</span>; <span class=\"hljs-comment\">// (name: string) =&gt; string</span>\nsayHello(<span class=\"hljs-string\">&quot;Mathieu&quot;</span>); <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\nsayHello(<span class=\"hljs-number\">42</span>); <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\n</code></pre>\n<h2>Les types primitifs et litéraux</h2>\n<p>Le nombre de types primitifs existants en JavaScript est assez restreint. Vous\navez le nombre (<code>number</code>), la chaine de caractères (<code>string</code>), les booléens\n(<code>boolean</code>), et bien évidemment les valeurs nulles (<code>null</code>) et inexistantes\n(<code>void</code>). À noter que ES2015 a également apporté (<code>Symbol</code>), mais que ce dernier\nn'est pas encore supporté par flow.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-keyword\">const</span> a: number = <span class=\"hljs-number\">42</span>;\n<span class=\"hljs-keyword\">const</span> b: string = <span class=\"hljs-string\">&quot;Je ne suis pas Coluche, certes&quot;</span>;\n<span class=\"hljs-keyword\">const</span> c: boolean = <span class=\"hljs-literal\">true</span>;\n<span class=\"hljs-keyword\">const</span> d: <span class=\"hljs-literal\">null</span> = <span class=\"hljs-literal\">null</span>;\n<span class=\"hljs-keyword\">const</span> e: <span class=\"hljs-keyword\">void</span> = <span class=\"hljs-literal\">undefined</span>;\n</code></pre>\n<p>Afin de vous montrer plus précis encore, vous pouvez également utiliser des\nvaleurs litérales comme type. Après tout <code>string</code>, ça peut être tout et\nn'importe quoi. Si cela peut vous sembler stupide dans un premier temps, ceux-ci\nsont <strong>extrêmement</strong> utiles lorsque le système de typage est suffisamment\nperfectionné, commme vous le verrez par la suite.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-keyword\">const</span> foo: <span class=\"hljs-string\">&quot;x&quot;</span> = <span class=\"hljs-string\">&quot;x&quot;</span>; <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\n<span class=\"hljs-keyword\">const</span> bar: <span class=\"hljs-number\">2</span> = <span class=\"hljs-number\">3</span>; <span class=\"hljs-comment\">// erreur! n&#x27;est pas égal à 2</span>\n</code></pre>\n<h2>La différence entre <code>any</code>, <code>mixed</code> et <code>*</code></h2>\n<p>Comme expliqué au dessus, utiliser <code>any</code> revient à dire à flow qu'une variable\npeut être de n'importe quel type et cela est bien sûr extrêmement dangereux.\nHeureusement, il existe 2 alternatives plus sûres à connaître :</p>\n<ul>\n<li><code>mixed</code> qui dit que peu importe le type de la variable passée à une fonction,\nl'appel de celle-ci doit pouvoir se faire correctement: vous ne pourrez donc\npas y appeler des méthodes spécifiques à un type de variable en particulier.</li>\n<li><code>*</code> qui laisse travailler l'inférence de type de flow.</li>\n</ul>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\">arg: mixed</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(arg);\n} <span class=\"hljs-comment\">// pas d&#x27;erreur: peu importe le type réel du paramètre arg, l&#x27;appel se fera correctement</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">bar</span>(<span class=\"hljs-params\">arg: mixed</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(arg.toUpperCase());\n} <span class=\"hljs-comment\">// erreur! arg pourrait ne pas être une string</span>\n\n<span class=\"hljs-keyword\">const</span> baz: <span class=\"hljs-built_in\">Array</span>&lt;*&gt; = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]; <span class=\"hljs-comment\">// inféré en Array&lt;number&gt;</span>\nbaz.push(<span class=\"hljs-string\">&quot;Hello&quot;</span>); <span class=\"hljs-comment\">// &quot;foo&quot; est maintenant inféré en Array&lt;number | string&gt; (tableau de string ou de numbers)</span>\n</code></pre>\n<h2>Les types optionnels (ou maybe types)</h2>\n<p>Si vous avez déjà utilisé un langage qui essaye d'éviter\n<a href=\"https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare\">l'erreur à un milliard de dollars</a>,\nvous connaissez sûrement les types <code>Option</code> / <code>Maybe</code>. Ils représentent la\npossible absence d'une valeur et sont ici symbolisés à l'aide d'un point\nd'interrogation.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-keyword\">let</span> foo: ?string; <span class=\"hljs-comment\">// peut-être une string, null ou undefined</span>\nfoo = <span class=\"hljs-string\">&quot;foo&quot;</span>; <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\nfoo = <span class=\"hljs-literal\">undefined</span>; <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\nfoo = <span class=\"hljs-literal\">null</span>; <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\nfoo = <span class=\"hljs-number\">3</span>; <span class=\"hljs-comment\">// erreur - number n&#x27;est ni une string, ni null, ni undefined</span>\n\ntype Bar = {\n  baz?: string, <span class=\"hljs-comment\">// baz sera forcément une string si elle est présente</span>\n};\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">wrongToUpperCase</span>(<span class=\"hljs-params\">str: ?string</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> str.toUpperCase(); <span class=\"hljs-comment\">// erreur, str est possiblement nul, vous devez traiter ce cas</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">correctToUpperCase</span>(<span class=\"hljs-params\">str: ?string</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> str === <span class=\"hljs-string\">&quot;string&quot;</span>) {\n    <span class=\"hljs-keyword\">return</span> str.toUpperCase(); <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\n  }\n}\n</code></pre>\n<h2>Les types génériques (generics)</h2>\n<p>Vous souvenez-vous de la syntaxe des tableaux (<code>Array&lt;any&gt;</code>) croisée plus tôt?\nIl s'agit de ce qu'on appelle un type générique : un type construit depuis un\nautre type. Ainsi, si <code>Array&lt;any&gt;</code> symbolise un tableau de tout et n'importe\nquoi, <code>Array&lt;number&gt;</code> symbolisera un tableau de numbers, etc.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-comment\">// on crée un type Classement qui prend en &quot;paramètre&quot; un type générique qu&#x27;on nomme &quot;T&quot;</span>\ntype Classement&lt;T&gt; = {\n  <span class=\"hljs-attr\">first</span>: T,\n  <span class=\"hljs-attr\">second</span>: T,\n  <span class=\"hljs-attr\">third</span>: T,\n};\n\n<span class=\"hljs-keyword\">const</span> numberClassement: Classement&lt;number&gt; = {\n  <span class=\"hljs-attr\">first</span>: <span class=\"hljs-number\">42</span>,\n  <span class=\"hljs-attr\">second</span>: <span class=\"hljs-number\">7</span>,\n  <span class=\"hljs-attr\">third</span>: <span class=\"hljs-number\">1</span>,\n};\n</code></pre>\n<p>Voici quelques exemples de types génériques disponibles out-of-the-box :</p>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-keyword\">const</span> foo: <span class=\"hljs-built_in\">Array</span>&lt;number&gt; = [];\n\n<span class=\"hljs-keyword\">const</span> bar: <span class=\"hljs-built_in\">Map</span>&lt;number, string&gt; = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>();\nbar.set(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&quot;one&quot;</span>);\n\n<span class=\"hljs-keyword\">const</span> baz: <span class=\"hljs-built_in\">Set</span>&lt;number&gt; = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>();\nbaz.add(<span class=\"hljs-number\">1</span>);\n\n<span class=\"hljs-keyword\">const</span> p: <span class=\"hljs-built_in\">Promise</span>&lt;number&gt; = <span class=\"hljs-built_in\">Promise</span>.resolve(<span class=\"hljs-number\">42</span>);\n</code></pre>\n<h2>La manipulation d'objets</h2>\n<p>Avez vous remarqué que pour le moment, j'ai tenté de ne pas utiliser d'objets au\nsein de mes exemples (oui, c'était chiant)? C'est tout simplement car les\npossibilités de manipulation des types de ceux-ci sont très nombreuses. Je vous\npropose un exemple fleuve histoire d'y voir plus clair.</p>\n<p>Un type objet se définit de la sorte :</p>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// @flow</span>\n\ntype User = {\n  <span class=\"hljs-attr\">name</span>: string,\n  <span class=\"hljs-attr\">pseudo</span>: string,\n};\n\n<span class=\"hljs-keyword\">const</span> user: User = {\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Mathieu&quot;</span>,\n  <span class=\"hljs-attr\">pseudo</span>: <span class=\"hljs-string\">&quot;zoontek&quot;</span>,\n};\n\n<span class=\"hljs-comment\">// Ce qui n&#x27;exclut pas de faire</span>\n<span class=\"hljs-keyword\">const</span> newUser: User = {\n  ...user,\n  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">26</span>,\n}; <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\n</code></pre>\n<p>Pour sceller les propriétés de notre objet, on utilise la notation <code>{||}</code> :</p>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// @flow</span>\n\ntype User = {|\n  name: string,\n  <span class=\"hljs-attr\">pseudo</span>: string,\n|};\n\n<span class=\"hljs-keyword\">const</span> user: User = {\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Mathieu&quot;</span>,\n  <span class=\"hljs-attr\">pseudo</span>: <span class=\"hljs-string\">&quot;zoontek&quot;</span>,\n};\n\n<span class=\"hljs-keyword\">const</span> newUser: User = {\n  ...user,\n  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">26</span>,\n}; <span class=\"hljs-comment\">// erreur! la propriété age n&#x27;existe pas</span>\n</code></pre>\n<p>Pour indiquer qu'une propriété de notre objet est immutable, on utilise la\nnotation <code>+</code>. Un must-have pour vos reducers Redux.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// @flow</span>\n\ntype User = {\n  +name: string,\n  <span class=\"hljs-attr\">pseudo</span>: string,\n};\n\n<span class=\"hljs-keyword\">const</span> user: User = {\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Mathieu&quot;</span>,\n  <span class=\"hljs-attr\">pseudo</span>: <span class=\"hljs-string\">&quot;zoontek&quot;</span>,\n};\n\nuser.name = <span class=\"hljs-string\">&quot;Jean-Michel&quot;</span>; <span class=\"hljs-comment\">// erreur! la valeur de name ne peut-être modifiée</span>\n\n<span class=\"hljs-keyword\">const</span> newUser: User = {\n  ...user,\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Jean-Michel&quot;</span>,\n}; <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\n</code></pre>\n<blockquote>\n<p>Le spreading c'est vraiment cool! Ça existe aussi pour les types?</p>\n</blockquote>\n<p>Yep.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// @flow</span>\n\ntype Foo = {| a: number, <span class=\"hljs-attr\">b</span>: string |};\ntype Bar = {| a: string |};\ntype Baz = {| ...Foo, ...Bar |}; <span class=\"hljs-comment\">// {| a: string, b: string |}</span>\n</code></pre>\n<p>Un dernier petit trick sur les objets pour la route? Vous pouvez les utiliser\ncomme maps :</p>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-keyword\">const</span> foo: { [key: string]: number } = {\n  <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-number\">42</span>,\n  <span class=\"hljs-attr\">baz</span>: <span class=\"hljs-string\">&quot;whatever&quot;</span>, <span class=\"hljs-comment\">// erreur! les valeurs des propriétés de cet objet doivent être de type number</span>\n};\n</code></pre>\n<h2>Les unions et intersections de types</h2>\n<p>Si vous avez remarqué la notation avec <code>|</code> plus tôt, vous vous posez sûrement la\nquestion de ce que ça représente. Il s'agit d'une union de types : la variable\naura une valeur à plusieurs types possibles. Petit conseil : utilisez toujours\nune union de types litéraux à la place du simple <code>string</code> lorsque vous\nconnaissez à l'avance les possibles valeurs de celui-ci.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sayHelloOrRound</span>(<span class=\"hljs-params\">arg: string | number</span>) </span>{\n  <span class=\"hljs-comment\">// arg peut être une string ou un number</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">typeof</span> arg === <span class=\"hljs-string\">&quot;string&quot;</span> ? <span class=\"hljs-string\">`Hello <span class=\"hljs-subst\">${arg}</span>`</span> : <span class=\"hljs-built_in\">Math</span>.round(arg);\n} <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\n\ntype Color = <span class=\"hljs-string\">&quot;red&quot;</span> | <span class=\"hljs-string\">&quot;green&quot;</span> | <span class=\"hljs-string\">&quot;blue&quot;</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">toHexadecimal</span>(<span class=\"hljs-params\">color: Color</span>) </span>{\n  <span class=\"hljs-keyword\">switch</span> (color) {\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;red&quot;</span>:\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;#FF0000&quot;</span>;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;green&quot;</span>:\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;#00FF00&quot;</span>;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;blue&quot;</span>:\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;#0000FF&quot;</span>;\n  }\n}\n\ntoHexadecimal(<span class=\"hljs-string\">&quot;red&quot;</span>); <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\ntoHexadecimal(<span class=\"hljs-string\">&quot;green&quot;</span>); <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\ntoHexadecimal(<span class=\"hljs-string\">&quot;blue&quot;</span>); <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\ntoHexadecimal(<span class=\"hljs-string\">&quot;pink&quot;</span>); <span class=\"hljs-comment\">// erreur! &quot;pink&quot; n&#x27;est pas une valeur possible</span>\ntoHexadecimal(<span class=\"hljs-string\">&quot;dog&quot;</span>); <span class=\"hljs-comment\">// erreur! &quot;dog&quot; n&#x27;est pas une valeur possible</span>\n</code></pre>\n<p>Parfois, une union de types se montre également bien plus efficace pour\nmodéliser ce que vous souhaitez, à contrario d'un tas de maybe types.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// @flow</span>\n\ntype ApiResponseBadlyTyped = {|\n  success: boolean,\n  value?: string, <span class=\"hljs-comment\">// value peut être présent</span>\n  error?: <span class=\"hljs-built_in\">Error</span>, <span class=\"hljs-comment\">// error peut être présent</span>\n|};\n\n<span class=\"hljs-keyword\">const</span> foo: ApiResponseBadlyTyped = { <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">true</span> }; <span class=\"hljs-comment\">// pas d&#x27;erreur alors que j&#x27;attends une value</span>\n<span class=\"hljs-keyword\">const</span> bar: ApiResponseBadlyTyped = { <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">error</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&quot;oups!&quot;</span>) }; <span class=\"hljs-comment\">// pas d&#x27;erreur non plus</span>\n\ntype ApiResponseCorrectlyTyped =\n  | {| success: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">value</span>: string |}\n  | {| success: <span class=\"hljs-literal\">false</span>, <span class=\"hljs-attr\">error</span>: <span class=\"hljs-built_in\">Error</span> |};\n\n<span class=\"hljs-keyword\">const</span> foo: ApiResponseCorrectlyTyped = { <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">true</span> }; <span class=\"hljs-comment\">// erreur! il manque value</span>\n<span class=\"hljs-keyword\">const</span> bar: ApiResponseCorrectlyTyped = {\n  <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-attr\">error</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&quot;oups!&quot;</span>),\n}; <span class=\"hljs-comment\">// erreur! si success est à true, on ne doit pas trouver d&#x27;error dans notre objet</span>\n<span class=\"hljs-keyword\">const</span> baz: ApiResponseCorrectlyTyped = {\n  <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-attr\">error</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&quot;oups!&quot;</span>),\n}; <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\n</code></pre>\n<p>Si les unions de types sont le <strong>OU</strong> logique du système de typage, les\nintersections de types en sont le <strong>ET</strong>. On les symbolise à l'aide d'un <code>&amp;</code>.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// @flow</span>\n\ntype Foo = { <span class=\"hljs-attr\">a</span>: number };\ntype Bar = { <span class=\"hljs-attr\">b</span>: string };\ntype Baz = { <span class=\"hljs-attr\">c</span>: boolean };\n\n<span class=\"hljs-keyword\">const</span> test: Foo &amp; Bar &amp; Baz = {\n  <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">42</span>,\n  <span class=\"hljs-attr\">b</span>: <span class=\"hljs-string\">&quot;whatever&quot;</span>,\n  <span class=\"hljs-attr\">c</span>: <span class=\"hljs-literal\">true</span>,\n}; <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\n\n<span class=\"hljs-keyword\">let</span> impossible: number &amp; string; <span class=\"hljs-comment\">// sera forcément impossible à initialiser : une valeur ne pourra jamais être un number ET une string</span>\n</code></pre>\n<p>C'est tout pour le moment! Vous vous doutez que l'on égratigne à peine la\nsurface de ce qui nous est offert par flow et les systèmes de typage fort en\ngénéral. Si vous êtes vraiment impatients de découvrir la suite, je vous renvoie\nvers la <a href=\"https://flow.org/en/docs/\">documentation de flow</a>, très bien foutue.\nPour les autres, on devrait sortir très prochainement un article sur le même\nsujet (on y parlera classes, interfaces et peut être même types opaques si vous\nêtes sages).</p>\n<p>Stay tuned! La bise.</p>\n"}}},"h":1,"l":{"RE_PRIVATE_NONE":true},"r":{"RE_PRIVATE_NONE":true}},"h":1,"l":{"RE_PRIVATE_NONE":true},"r":{"RE_PRIVATE_NONE":true}},"listsRequests":{"data":{"RE_PRIVATE_NONE":true}},"itemsRequests":{"data":{"RE_PRIVATE_NONE":true}}}</script><script defer="defer" src="/public/main.7dbdfae3625332f5ea04.js"></script></html>